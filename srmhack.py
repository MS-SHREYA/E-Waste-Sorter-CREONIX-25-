# -*- coding: utf-8 -*-
"""SRMHack.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fzkjjUns6dLwrn7NxTZnTBnOg1vhgWLs
"""

# --- 1. INSTALL LIBRARIES ---
!pip install -q gradio ultralytics opencv-python numpy

# --- 2. IMPORT LIBRARIES ---
import gradio as gr
import cv2
import os
import random
import numpy as np
from ultralytics import YOLO
from collections import defaultdict

# --- 3. LOAD YOUR AI MODEL ---
# Make sure your Google Drive is mounted and the path is correct
from google.colab import drive
drive.mount('/content/drive')
MODEL_PATH = '/content/best (1).pt'

try:
    model = YOLO(MODEL_PATH)
    print("✅ AI Model loaded successfully.")
except Exception as e:
    print(f"❌ CRITICAL ERROR: Could not load the model. Please check the path: {e}")
    raise SystemExit("Model loading failed.")

# --- 4. COMPONENT DATABASE WITH ALL DETAILS ---
COMPONENT_DATABASE = {
    'ic': {'tier': 'High-Value', 'score': 10, 'description': "are prime candidates for harvesting due to their high resale value and functionality.", 'hazardous': False},
    'coil': {'tier': 'Medium-Value', 'score': 3, 'description': "are valuable for their copper content and are often reused in power circuits.", 'hazardous': False},
    'mosfet': {'tier': 'Medium-Value', 'score': 3, 'description': "are key components in power regulation and are frequently harvested for repair.", 'hazardous': True},
    'transistor': {'tier': 'Low-Value', 'score': 0, 'description': "", 'hazardous': True},
    'default': {'tier': 'Low-Value', 'score': 0, 'description': "", 'hazardous': False}
}

# --- 5. THE MAIN ANALYSIS FUNCTION ---
def analyze_pcb_with_gradio(input_image):
    img = cv2.cvtColor(input_image, cv2.COLOR_RGB2BGR)
    results = model(img)

    # --- Analysis Logic ---
    component_counts = defaultdict(int)
    reusability_score = 0
    total_components = 0
    detailed_factors = defaultdict(list)
    is_hazardous = False

    for box in results[0].boxes:
        total_components += 1
        class_name = model.names[int(box.cls[0])]
        confidence = float(box.conf[0])
        component_counts[class_name] += 1

        data = COMPONENT_DATABASE.get(class_name, COMPONENT_DATABASE['default'])
        reusability_score += data['score']

        if data['score'] > 0:
            detailed_factors[class_name.capitalize()].append(data['description'])

        if data['hazardous']:
            is_hazardous = True

        # Drawing bounding boxes
        x1, y1, x2, y2 = map(int, box.xyxy[0])
        label = f"{class_name} {confidence:.2f}"
        cv2.rectangle(img, (x1, y1), (x2, y2), (0, 255, 0), 2)
        cv2.putText(img, label, (x1, y1 - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 0), 2)

    if total_components > 50:
        reusability_score += 15
        detailed_factors["Board Complexity"].append("This board has a high component density, often indicating a more valuable board.")

    # --- 6. SEGREGATION RECOMMENDATION LOGIC ---
    if is_hazardous:
        recommendation = "☣️ HAZARDOUS: Segregate for special disposal."
    elif reusability_score >= 20:
        recommendation = "♻️ REUSABLE: Segregate for component harvesting."
    else:
        recommendation = "⚙️ GENERAL RECYCLING: Route to standard shredding process."

    # --- 7. FORMAT THE DETAILED REPORT ---
    report = "--- FULL BOARD ANALYSIS REPORT ---\n\n"
    report += "[ 1. COMPONENT SUMMARY ]\n"
    for component, count in component_counts.items():
        report += f"- {component.capitalize()}: {count} units\n"

    report += "\n[ 2. DETAILED REUSABILITY ANALYSIS ]\n"
    if reusability_score >= 40: verdict = "Prime Candidate for Component Harvesting."
    elif reusability_score >= 10: verdict = "Good Potential for Reuse."
    else: verdict = "Low Potential for Reuse."
    report += f"Reusability Score: {reusability_score} / 100\n"
    report += f"Verdict: {verdict}\n"

    if detailed_factors:
        report += "\nFactors Considered in This Decision:\n"
        for component_name, descriptions in detailed_factors.items():
            unique_description = descriptions[0]
            count = component_counts.get(component_name.lower(), len(descriptions))
            if "Board Complexity" in component_name:
                 report += f"  {component_name}: {unique_description}\n"
            else:
                 report += f"  {count} x {component_name}: Detected. These {unique_description}\n"

    annotated_image = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    return recommendation, report, annotated_image

# --- 8. CREATE AND LAUNCH THE GRADIO INTERFACE ---
iface = gr.Interface(
    fn=analyze_pcb_with_gradio,
    inputs=gr.Image(type="numpy", label="Upload PCB Image"),
    outputs=[
        # ✨ MODIFIED: Recommendation box is now a single line again
        gr.Textbox(label="✅ Final Segregation Recommendation"),
        # ✨ MODIFIED: Detailed report box is large
        gr.Textbox(label="Detailed Analysis Report", lines=20),
        gr.Image(type="numpy", label="Detection Result", height=600)
    ],
    title="E-Waste PCB Analyzer & Sorter",
    description="Upload a circuit board image to get a detailed analysis and a clear segregation recommendation.",
    allow_flagging="never"
)

# Launch the app with a public link
iface.launch(share=True, debug=True)

